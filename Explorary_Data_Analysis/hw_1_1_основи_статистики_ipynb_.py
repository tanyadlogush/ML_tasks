# -*- coding: utf-8 -*-
""""HW 1.1 Основи статистики.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qqPNwPQU9q3yD4RVLDHw5nUSe1MytqYB

**Завдання 1.** Ми обговорили з Вами на лекції, що велика літера Сігма грецького алфавіту позначає в математиці суму. Знайдіть з використанням Python $\Sigma x$, $\Sigma x^2$, та $\Sigma (x-1)^2$ для наступного набору даних:
`1 3 4`
Виведіть результат кожного обчислення на екран.
"""

data = [1, 3, 4]
sum1 = sum(data)
sum2 = sum([x ** 2 for x in data])
sum3 = sum([(x - 1) ** 2 for x in data])
print(f'Σx = {sum1}')
print(f'Σx^2 = {sum2}')
print(f'Σ(x-1)^2 = {sum3}')

"""**Завдання 2.** Ми зібрали дані про суму покупок в гривнях 20ма випадково обраними клієнтами в нашому магазині (всього клієнтів у нас більше) за минулий місяць. Вони представлені в змінній `sum_purchases`. Знайдіть **вибіркове середнє** для цих даних кожним з зазначених методів:   

  2.1. без використання жодних бібліотек, користуючись тільки Python.  
  2.2. використовуючи відповідний метод бібліотеки `numpy`.

  Виведіть результат обчислень в кожному з випадків на екран та порівняйте результати. Вони співпадають?
"""

sum_purchases = [ 316,  493,  367,  153,  224,  121,  322,  450,  196,  397,  281,
  239,  484,  124,  223,  448,  432,  255, 4310, 3524]

import numpy as np


sample_mean_py = sum(sum_purchases) / len(sum_purchases)
sample_mean_np = np.mean(sum_purchases)
print('Вибіркове середнє Python:', sample_mean_py)
print('Вибіркове середнє NumPy:', sample_mean_np)

"""**Завдання 3.** Для того ж набору даних в змінній `sum_purchases` обчисліть **медіану** кожним з зазначених методів:  

  3.1. без використання жодних бібліотек, користуючись тільки Python.  
  3.2. використовуючи відповідний метод бібліотеки numpy.  

Виведіть результат обчислень в кожному з випадків на екран. Порівняйте результати зі значенням вибіркового середнього. Напишіть коментар, для яких задач ви б використовували вибіркове середнє, а для яких - медіану?
"""

sorted_sum_purchases = sorted(sum_purchases)
l = len(sorted_sum_purchases)
middle = l // 2

median_py = (sorted_sum_purchases[middle] + sorted_sum_purchases[middle - (l + 1) % 2]) / 2
median_np = np.median(sum_purchases)

print('Медіана Python:', median_py)
print('Медіана NumPy:', median_np)

"""**Завдання 4**. Обчислість стандартне відхилення наведеної вибірки в змінній `sum_purchases` кожним з зазначених методів:  

  4.1. без використання жодних бібліотек, користуючись тільки Python.  
  4.2. використовуючи відповідний метод бібліотеки numpy.  

Виведіть результат обчислень в кожному з випадків на екран.
"""

n = len(sum_purchases)
mean_sp_np = np.mean(sum_purchases)

std_sp_py = ((sum([(x - mean_sp_np) ** 2 for x in sum_purchases])) / (n - 1)) ** 0.5

std_sp_np = np.std(sum_purchases, ddof=1)

print('Стандартне відхилення Python:', std_sp_py.round(2))
print('Стандартне відхилення PNumPy:', std_sp_np.round(2))

"""**Завдання 5**. Ми провели дослідження віку студентів-першокурсників. Виявилось, що
- 10 студентів мають вік 16 років
- 25 студентів - 17 років
- 20 студентів - 18 років
- 2 студенти - 20 років

Обчислість середнє значення для цієї вибірки будь-яким способом - на чистому Python або з numpy - та виведіть результат на екран.
"""

age_list = [16] * 10 + [17] * 25 + [18] * 20 + [20] * 2
mean_age = np.mean(age_list)
print('Середнє значення вибірки:', mean_age.round(2))

"""**Завдання 6**. Крім даних про суму покупок, ми зібрали ще дані про кількість відвідувань кожного з кожного покупця, які знаходяться в змінній `visits`. Обчисліть коефіцієнт кореляції Пірсона для суми покупок і кількості відвідувань кожним з зазначених методів:  

  6.1. без використання жодних бібліотек, користуючись тільки Python.  
  6.2. використовуючи відповідний метод бібліотеки numpy.  
  
Виведіть результат на екран. Проаналізуйте результат.

Виведіть додатково графік розсіювання викликавши код нижче і зробіть заключення, чи варто щось змінити при підрахунку кореляції, аби коефіцієнт Пірсона показував коректну оцінку лінійної залежності?
"""

visits = [ 6,  2, 10,  3,  9,  9,  2,  3,  6,  6, 10,  2,  5, 10,  3,  5,  4,
        7,  4,  2]

# Середнє та стандартне відхилення для sum_purchases (as sp) з попередніх завдань:
mean_sp = mean_sp_np
std_sp = std_sp_np

# Середнє та стандартне відхилення для visits (as vis):
mean_vis = np.mean(visits)
std_vis = np.std(visits, ddof=1)

# Коваріація Python (_py) і NumPy (_np):
cov_py = (sum([(s - mean_sp)*(v - mean_vis) for s, v in zip(sum_purchases, visits)])) / (len(visits)-1)
cov_np = np.cov(sum_purchases, visits, ddof=1)[0, 1]

print('Коваріація Python:', cov_py.round(2))
print('Коваріація NumPy:', cov_np.round(2))
print()

# Коефіцієнт кореляції Пірсона Python (_py) і NumPy (_np):
r_py = cov_py/(std_sp * std_vis)
r_np = np.corrcoef(sum_purchases, visits)[0, 1]

print('Коефіцієнт кореляції Пірсона Python:', r_py.round(2))
print('Коефіцієнт кореляції Пірсона NumPy:', r_np.round(2))

"""## Висновки:
Коваріація негативна, коефіцієнт кореляції Пірсона (ближчий до 0, ніж до -1) свідчить про слабкий зворотній зв'язок між змінними. Передбачення щодо зміни однієї змінної через зміну другої будуть неточними, хоча можна прогнозувати їх напрямок: збільшення однієї величини призведе до зменшення другої.
"""

import matplotlib.pyplot as plt

plt.scatter(sum_purchases, visits)
plt.title('Scatter Plot of Purchases vs. Visits')
plt.xlabel('Sum of Purchases')
plt.ylabel('Number of Visits');

"""**Завдання 7**. В попередньому завданні ми помітили, що викиди нам заважають отримати "правдиве" значення кореляції. Давайте вилучимо записи, які відповідають значенням з викидами в сумі покупок і обчисліть коеф. кореляції. Для цього поставте `threshold`, який дорінює середньому значенню + 2 стандартних вдіхилля суми покупок і всі значення, які більше за нього, будемо вважати викидами (є і інші правила для визначення викидів - з ним и познайомимось пізніше).

Вилучіть значення з обох масивів і обчисліть коеф. кореляції Пірсона з допомогою `numpy` для кількості візитів і суми покупок без записів-викидів. Виведіть результат на екран, побудуйте діаграму розсіювання і проаналізуйте результат: що можемо сказати про залежність в даних?
"""

threshold = mean_sp + 2 * std_sp

# Очищені від викидів масиви даних:
new_sp = [i for i in sum_purchases if i <= threshold]
new_vis = [visits[i] for i in range(len(visits)) if sum_purchases[i] <= threshold]

# Перерахунок коефіцієнт кореляції Пірсона:
new_r = np.corrcoef(new_sp, new_vis)[0, 1]
print('Оновлений коефіцієнту кореляції Пірсона:', new_r.round(2))

plt.scatter(new_sp, new_vis)
plt.title('Scatter Plot of New_Purchases vs. New_Visits')
plt.xlabel('Sum of New_Purchases')
plt.ylabel('Number of New_Visits');

"""  ## Висновки після вилучення викидів із даних:
  змінні мають зворотню залежність, зв'язок став більш вираженим, але все ще доволі слабкий. Прогнозування змін все ще даватиме недостатню точність.

"""